name: MLOps CI/CD Pipeline

on:
  push:
    branches: [main, master]
  workflow_dispatch:

env:
  PROJECT_ID: adroit-metric-473508-k1
  GKE_CLUSTER: iris-cluster
  GKE_ZONE: us-central1
  DEPLOYMENT_NAME: heart-disease-app
  IMAGE_NAME: heart-disease-app
  ARTIFACT_REGISTRY: us-central1-docker.pkg.dev
  REPOSITORY: heart-disease-repo

jobs:
  setup-build-deploy:
    name: Setup, Build, and Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
      with:
        install_components: 'gke-gcloud-auth-plugin'

    - name: Configure Docker
      run: |
        gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}

    - name: Build Docker Image
      run: |
        docker build -f deployment/Dockerfile -t ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} .
        docker tag ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
                   ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:latest

    - name: Push Docker Image
      run: |
        docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        docker push ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:latest

    - name: Get GKE Credentials
      run: |
        export USE_GKE_GCLOUD_AUTH_PLUGIN=True
        gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} --zone ${{ env.GKE_ZONE }}

    - name: Deploy to Kubernetes
      run: |
        export USE_GKE_GCLOUD_AUTH_PLUGIN=True
        
        # Apply all Kubernetes manifests
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/hpa.yaml
        
        # Update the deployment image to the new version
        kubectl set image deployment/${{ env.DEPLOYMENT_NAME }} \
          heart-disease-fastapi=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          --record
        
        # Wait for rollout to complete
        kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }}

    - name: Health Checks
      run: |
        export USE_GKE_GCLOUD_AUTH_PLUGIN=True
        echo "Waiting for LoadBalancer IP..."
        sleep 30
        
        EXTERNAL_IP=$(kubectl get svc heart-disease-lb -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "External IP: $EXTERNAL_IP"
        
        if [ -z "$EXTERNAL_IP" ]; then
          echo "ERROR: LoadBalancer IP not assigned yet"
          kubectl describe svc heart-disease-lb
          exit 1
        fi
        
        echo "Testing /ready_check endpoint..."
        curl -f http://${EXTERNAL_IP}/ready_check || exit 1
        echo "‚úÖ Health check passed!"

    - name: Deployment Summary
      if: success()
      run: |
        export USE_GKE_GCLOUD_AUTH_PLUGIN=True
        echo "üéâ Deployment successful!"
        echo ""
        echo "Deployment:"
        kubectl get deployment ${{ env.DEPLOYMENT_NAME }}
        echo ""
        echo "Pods:"
        kubectl get pods -l app=${{ env.DEPLOYMENT_NAME }}
        echo ""
        echo "Service:"
        kubectl get svc heart-disease-lb
        echo ""
        EXTERNAL_IP=$(kubectl get svc heart-disease-lb -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "üåê API URL: http://${EXTERNAL_IP}"
